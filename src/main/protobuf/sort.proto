syntax = "proto3";

package rpc;

option java_multiple_files = true;
option java_package = "rpc";

// ---------- Common Types ----------
message Ack {
  bool ok = 1;
  string msg = 2;
}

message WorkerInfo {
  string id   = 1;   // Worker Identifier
  string ip = 2;                    // Worker IP address
  int32 port = 3;                   // Worker gRPC port
  repeated string input_dirs = 4;   // Input directories (from -I flag)
  string output_dir = 5;            // Output directory (from -O flag)
}

message WorkerAssignment {
  bool success = 1;                 // Registration success
  string message = 2;               // Response message
  int32 worker_id = 3;              // Assigned worker ID (0, 1, 2, ...)
  repeated int32 partition_ids = 4; // Partition IDs to handle (for later)
  int32 assigned_port = 5;
}

// ---------- Sampling ----------
message Sample { bytes key = 1; }                 // 10B
message Splitters { repeated bytes key = 1; }     // k-1 splitter keys

// ---------- Partition (master -> worker) ----------
message TaskId { string id = 1; }

message PartitionRange {
  bytes lo = 1;             // inclusive
  bytes hi = 2;             // exclusive
  int32 target_worker = 3;  // Destination worker ID
}

message WorkerAddress {
  int32 worker_id = 1;
  string ip = 2;
  int32 port = 3;
}

message PartitionPlan {
  TaskId task = 1;
  repeated PartitionRange ranges = 2;
  repeated WorkerAddress workers = 3;
}

// ---------- Shuffle(worker -> worker) ----------

message PartitionChunk {
  TaskId task = 1;
  string partition_id = 2;  // e.g., "p0" 
  int32 sender_id = 3;
  bytes payload = 4;        // Multiple 100-byte records
  int64 seq = 5;            // Sequence number for ordering/retries
}

message StreamDone {
  TaskId task = 1;
  string partition_id = 2;
  string checksum = 3;
}
message BlockMeta {
  string block_id = 1;
  string path = 2;
  int64  size = 3;
}

// ---------- Services ----------
// (Called by workers against the master)
service MasterService {
  // Week 3: Worker registration
  rpc RegisterWorker(WorkerInfo) returns (WorkerAssignment);

  // Week 4: Heartbeat and sampling
  rpc Heartbeat(WorkerInfo) returns (Ack);
  rpc SendSamples(stream Sample) returns (Splitters);

  // Week 5: Shuffle - coordination
  rpc ReportShuffleComplete(ShuffleCompletionReport) returns (Ack);
  rpc QueryPartitionSenders(PartitionSendersQuery) returns (PartitionSendersResponse);
  
  rpc ReportMergeComplete(WorkerStatus) returns (Ack);
}

// (Called by the master/workers against a worker)
service WorkerService {
  // Week 4+: Partition plan distribution
  rpc SetPartitionPlan(PartitionPlan) returns (Ack);

  // Week 5: Shuffle - receive partition data
  rpc PushPartition(stream PartitionChunk) returns (Ack);

  rpc StartShuffle(TaskId) returns (Ack);
  rpc FinalizePartitions(TaskId) returns (Ack);
  
  rpc RecoverPartitions(RecoveryRequest) returns (Ack);
  rpc RequestPartition(PartitionRequest) returns (stream PartitionChunk);
}

message WorkerStatus {
  int32 worker_id = 1;
  string phase = 2;  // "shuffle_complete", "merge_complete"
  int64 timestamp = 3;
}

message ShuffleCompletionReport {
  int32 worker_id = 1;
  repeated PartitionSendRecord send_records = 2;
}

message PartitionSendRecord {
  int32 partition_id = 1;
  int32 target_worker_id = 2;
  int32 sender_id = 3;  // 보낸 사람 (자기 자신)
  bool success = 4;
}

message PartitionSendersQuery {
  int32 partition_id = 1;
}

message PartitionSendersResponse {
  int32 partition_id = 1;
  repeated int32 sender_ids = 2;
}

message RecoveryRequest {
  repeated int32 partition_ids = 1;
}

message PartitionRequest {
  int32 partition_id = 1;
  int32 requester_id = 2;
}
